name: PR Python Type & Format Check

on:
  pull_request:
    types: [labeled]
  workflow_dispatch: {}

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  check-py-files:
    runs-on: windows-latest
    outputs:
      has_py: ${{ steps.detect.outputs.has_py }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive
          persist-credentials: true
          token: ${{ secrets.SUBMODULE_TOKEN }}


      - name: Detect Python file changes
        id: detect
        shell: pwsh
        env:
          BASE_REF: ${{ github.event.pull_request.base.ref }}
          HEAD_REF: ${{ github.event.pull_request.head.ref }}
        run: |
          Write-Output "Base ref: $env:BASE_REF"
          Write-Output "Head ref: $env:HEAD_REF"
          # Ensure the base ref is available locally
          git fetch origin $env:BASE_REF --no-tags --prune

          # Try to find changed files between base and the head commit.
          # Use a robust strategy: try three-dot range first, fall back to two-dot range.
          $files = ''
          try {
            $files = git diff --name-only origin/$env:BASE_REF...HEAD 2>&1
            if ($LASTEXITCODE -ne 0) { throw $files }
          } catch {
            Write-Output "git diff (three-dot) failed: $_"
            Write-Output "Attempting fallback two-dot range..."
            try {
              $files = git diff --name-only origin/$env:BASE_REF..HEAD 2>&1
              if ($LASTEXITCODE -ne 0) { throw $files }
            } catch {
              Write-Output "git diff fallback failed: $_"
              Write-Output "Unable to compute diff safely (no merge base?). Defaulting to run checks."
              echo "has_py=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
              return
            }
          }

          $py = $files | Where-Object { $_ -like '*.py' }

          if ($py) {
            Write-Output "Python changes detected"
            echo "has_py=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          } else {
            Write-Output "No Python changes"
            echo "has_py=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }

  check-py-type-and-format:
    runs-on: windows-latest
    needs: [check-py-files]
    if: ${{ github.event_name == 'workflow_dispatch' || (github.event_name == 'pull_request' && github.event.label && github.event.label.name == 'ready-to-merge' && needs.check-py-files.outputs.has_py == 'true') }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          submodules: recursive
          persist-credentials: true
          token: ${{ secrets.SUBMODULE_TOKEN }}

      - name: Read .python-version
        id: pyver
        shell: pwsh
        run: |
          if (Test-Path '.python-version') {
            $v = Get-Content .python-version -Raw
            $v = $v.Trim()
            if ($v) { echo "python=$v" | Out-File -FilePath $env:GITHUB_OUTPUT -Append }
            else { echo "python=3.11" | Out-File -FilePath $env:GITHUB_OUTPUT -Append }
          } else {
            echo "python=3.11" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }

      - name: Set up Python from .python-version
        uses: actions/setup-python@v4
        with:
          python-version: ${{ steps.pyver.outputs.python }}

      - name: Install uv task runner and build tools
        shell: pwsh
        run: |
          python -m pip install --upgrade pip
          pip install setuptools wheel
          pip install uv

      - name: sync dev (type packs)
        shell: pwsh
        run: |
          uv sync --extra tpc-packs

      - name: check type
        id: run_tpc
        shell: pwsh
        continue-on-error: true
        run: |
          # run type check and capture output and exit code into step outputs (avoid files)
          $out = uv run tpc --exclude .*SecretAPI.* 2>&1
          $code = $LASTEXITCODE
          # write multiline output to GITHUB_OUTPUT
          Write-Output "tpc output length: $($out.Length)"
          "tpc_output<<EOF" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          $out | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "EOF" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

          echo "tpc_exit=$code" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

          # Determine failure: either non-zero exit code or mypy-style summary "Found X errors"
          $failed = $false
          if ($out -match 'Found\s+\d+\s+errors') { $failed = $true }
          elseif ($code -ne 0) { $failed = $true }

          if ($failed) {
            echo "tpc_failed=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          } else {
            echo "tpc_failed=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }

      - name: sync format dev
        shell: pwsh
        run: |
          uv sync --extra fmt-packs

      - name: Run formatter
        shell: pwsh
        run: |
          uv run fmt

      - name: Detect formatting changes
        id: detect_changes
        shell: pwsh
        run: |
          git add -A
          # Ensure temporary files created by checks are NOT staged
          git reset -- tpc_output.txt tpc_exit.txt fmt_diff.txt 2>$null || Out-Null

          # save staged diff for comment into step output (avoid writing fmt_diff.txt)
          $diff = git --no-pager diff --cached || ''
          "fmt_diff<<EOF" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          $diff | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          "EOF" | Out-File -FilePath $env:GITHUB_OUTPUT -Append

          $status = git status --porcelain
          if ($status) {
            Write-Output "Formatting changes detected"
            echo "changed=true" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          } else {
            Write-Output "No formatting changes"
            echo "changed=false" | Out-File -FilePath $env:GITHUB_OUTPUT -Append
          }
      - name: Setup Node (for GitHub App token generation)
        uses: actions/setup-node@v4
        with:
          node-version: '18'

      - name: Install token helper dependencies
        run: |
          npm init -y
          npm install jsonwebtoken node-fetch@2

      - name: Generate GitHub App installation token
        id: get_app_token
        env:
          APP_ID: ${{ secrets.APP_ID }}
          APP_PRIVATE_KEY: ${{ secrets.APP_PRIVATE_KEY }}
        shell: pwsh
        run: |
          $js = @'
          const fs = require('fs');
          const jwt = require('jsonwebtoken');
          const fetch = require('node-fetch');

          const appId = process.env.APP_ID;
          const rawKey = process.env.APP_PRIVATE_KEY || '';
          if (!appId || !rawKey) {
            console.error('Missing APP_ID or APP_PRIVATE_KEY');
            process.exit(1);
          }
          const privateKey = rawKey.includes('\\n') ? rawKey.replace(/\\n/g, '\n') : rawKey;

          const now = Math.floor(Date.now() / 1000);
          const payload = { iat: now - 60, exp: now + 9 * 60, iss: appId };
          const token = jwt.sign(payload, privateKey, { algorithm: 'RS256' });

          (async () => {
            const repo = process.env.GITHUB_REPOSITORY;
            const [owner, repoName] = repo.split('/');
            const repoInstallRes = await fetch(`https://api.github.com/repos/${owner}/${repoName}/installation`, {
              headers: { Authorization: `Bearer ${token}`, Accept: 'application/vnd.github+json' }
            });
            if (!repoInstallRes.ok) {
              console.error('Failed to get repo installation:', await repoInstallRes.text());
              process.exit(2);
            }
            const repoInstall = await repoInstallRes.json();
            const installationId = repoInstall.id;

            const res = await fetch(`https://api.github.com/app/installations/${installationId}/access_tokens`, {
              method: 'POST',
              headers: { Authorization: `Bearer ${token}`, Accept: 'application/vnd.github+json' }
            });
            if (!res.ok) {
              console.error('Failed to create installation token:', await res.text());
              process.exit(3);
            }
            const body = await res.json();
            const appToken = body.token;
            if (!appToken) {
              console.error('No token returned');
              process.exit(4);
            }
            fs.appendFileSync(process.env.GITHUB_OUTPUT, `token=${appToken}\n`);
          })();
          '@
          Set-Content -Path token-gen.js -Value $js -Encoding utf8
          node token-gen.js

      - name: Post combined structured comment (Type + Formatter)
        uses: actions/github-script@v6
        env:
          TPC_OUTPUT: ${{ steps.run_tpc.outputs.tpc_output }}
          FMT_DIFF: ${{ steps.detect_changes.outputs.fmt_diff }}
          TPC_FAILED: ${{ steps.run_tpc.outputs.tpc_failed }}
          FMT_CHANGED: ${{ steps.detect_changes.outputs.changed }}
        with:
          github-token: ${{ steps.get_app_token.outputs.token }}
          script: |
            const pr = context.payload.pull_request;
            if (!pr) { core.info('No pull_request context; skipping comment.'); return; }
            function escapeHtml(s){ return s ? s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;') : ''; }

            // Build structured single comment with two expandable sections
            let body = '**Automated pre-merge checks detected issues**\n\n';

            // Type check section
            body += '<details open>\n<summary><strong>Type check failures (uv run tpc)</strong></summary>\n\n';
            const out = process.env.TPC_OUTPUT || '';
            if (out.trim().length > 0) {
              body += '<pre>' + escapeHtml(out) + '</pre>\n';
            } else {
              body += '_No type-check output captured_\n';
            }
            body += '</details>\n\n';

            // Formatter section
            body += '<details>\n<summary><strong>Formatter changes (staged diff)</strong></summary>\n\n';
            const diff = process.env.FMT_DIFF || '';
            if (diff.trim().length > 0) {
              body += '<pre>' + escapeHtml(diff) + '</pre>\n';
            } else {
              body += '_No staged diff content_\n';
            }
            body += '</details>\n\n';

            body += 'Summary:\n';
            body += `- Type check: ${process.env.TPC_FAILED === 'true' ? 'FAILED' : 'OK'}\n`;
            body += `- Formatter changes: ${process.env.FMT_CHANGED === 'true' ? 'Detected' : 'None'}\n\n`;

            body += 'To fix locally:\n<pre>uv run tpc\nuv run fmt\ngit add -A\ngit commit -m "chore(format): apply formatting"\ngit push</pre>';

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body,
            });

      - name: Fail if issues found
        if: ${{ steps.run_tpc.outputs.tpc_failed == 'true' || steps.detect_changes.outputs.changed == 'true' }}
        shell: pwsh
        run: |
          Write-Output "One or more checks failed (type check or formatting). See PR comment for details."
          exit 1
